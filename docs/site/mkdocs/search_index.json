{
    "docs": [
        {
            "location": "/",
            "text": "```@meta\nCurrentModule = ScenTrees\n\n\n#\nScenTrees\n.\njl\n\n\n\n!!!\n \nwarning\n\n    `\nScenTrees\n.\njl\n` \nis\n \nstill\n \nunder\n \ndevelopment\n.\n\n`\nScenTrees\n.\njl\n` \nis\n \na\n \npackage\n \nfor\n \ngenerating\n \nand\n \nimproving\n \nscenario\n \ntrees\n \nand\n \nscenario\n \nlattices\n \nfor\n \nmultistage\n \nstochastic\n \noptimization\n \nusing\n \n_stochastic\n \napproximation_\n.\n\nIn\n \nthis\n \nexplanation\n, \nwe\n \nassume\n \nthat\n \nthe\n \nreader\n \nis\n \nquite\n \nfamiliar\n \nwith\n \nthe\n \ntheory\n \nand\n \nexplanation\n \nin\n \nthe\n \npaper\n \n_Dynamic\n \nGenaration\n \nof\n \nScenario\n \nTrees\n \nby\n \nPflug\n \nand\n \nPichler_\n.\n\n\n!!!\n \ntip\n \n    \nIf\n \nyou\n \nhaven\n'\nt, you don\n'\nt\n \nhave\n \nto\n \nworry\n. \nHere\n \nis\n \nthe\n \nlink\n:\n    [\nDynamic\n \nGeneration\n \nof\n \nScenario\n \nTrees\n]\n(\nhttps\n:\n//\nlink\n.\nspringer\n.\ncom\n/\narticle\n/\n10\n.\n1007\n/\ns10589\n-\n015\n-\n9758\n-\n0\n)\n\n\n## \nInstallation\n\n\n\nYou\n \ncan\n \ninstall\n `\nScenTrees\n.\njl\n` \nas\n \nfollows\n:\n\n```\njulia\n\n]\n\nadd\n \nhttps\n:\n//\ngithub\n.\ncom\n/\nkirui93\n/\nScenTrees\n.\njl\n.\ngit\n\n\n\n\n\n\nCiting \nScenTrees.jl\n\n\n!!! info\n    To be added.",
            "title": "Introduction"
        },
        {
            "location": "/#citing-scentreesjl",
            "text": "!!! info\n    To be added.",
            "title": "Citing ScenTrees.jl"
        },
        {
            "location": "/tutorial/tutorial1/",
            "text": "Introduction\n\n\nMultistage stochastic optimization involves approximating a stochastic process in by a finite structure.\nWe call these structures a scenario tree and a scanrio lattice.\nScenario lattices plays an important role in approximating Markovian data processes.\n\n\nWe will look at the basic functionality of \nScenTrees.jl\n just to highlight on how it works.\n\n\nGoal\n\n\nThe goal is to generate a valuated probability tree or a lattice which represents the stochastic process in the best way possible.\n\n\nTo measure the quality of the approximation, we use a process distance between the stochastic process and the scanario tree or lattice.\n\n\nDescription of a scenario tree\n\n\nA scenario tree is characterized by the following:\n\n\n\n\nName of the tree\n\n\nParents of the nodes in the tree\n\n\nChildren of the parents in the tree \n\n\nStates of the nodes in the tree\n\n\nProbabilities of transition from one node to another.\n\n\n\n\nThe tree is also characterized by its \nnodes\n, \nstages\n, \nheight\n,\nleaves\n and the \nroot\n of the tree or the nodes.\n\n\nEach tree has stages starting from \n0\n where the root node is. \n\n\nDescription of a scenario lattice\n\n\nA scenario lattice differs from a scenario tree in that every node in stage \nt\n is a child for each node in stage \nt-1\n. So the nodes in stage \nt-1\n share the same children.\n\n\nDue to the above, we only describe a scenario lattice by:\n\n\n\n\nName of the lattice \n\n\nStates of the nodes of the lattice\n\n\nProbabilities of transition from one node to another in the lattice\n\n\n\n\nUsage\n\n\nSince we have the basics of the scenario tree and the scenario lattice and since we created \nScenTrees.jl\n \nwith an intention of being user-friendly, we will give an example of its usage and explain each part of it.\n\n\nusing\n \nScenTrees\n\n\n\nex1\n \n=\n \nTree\n([\n1\n,\n3\n,\n3\n,\n3\n,\n3\n]);\n\n\nsol1\n \n=\n \nTreeApproximation!\n(\nex1\n,\n \nGaussianSamplePath\n,\n \n100000\n,\n2\n,\n2\n);\n\n\n\ntreeplot\n(\nsol1\n)\n\n\n\n\n\n\nIn the above, we are creating a scenario tree with the branching structure \n1x3x3x3x3\n as \nex1\n. \nWe want to approximate the Gaussian random walk with this tree.\nSo, the tree approximation process takes 4 inputs:\n\n\n\n\nA tree\n\n\nThe process to be approximated\n\n\nSample size\n\n\nWhich norm (default to Euclidean norm = 2)\n\n\nThe value of \nr\n for process distance ( default to \nr=2\n)\n\n\n\n\nThose are basically the inputs that we are giving to the function \nTreeApproximation!\n. \nWhat we obtain as a result of this is a valuated tree which can be visualized by the function \ntreeplot\n or \nplotD\n if incase you were dealing with a 2-dimensional state space.\n\n\n\n\nJust as easy as that! \n\n\nIt is more even simple for lattice approximation as in this we only take as inputs the branching structure of the lattice and the sample size as follows:\n\n\nsol2\n \n=\n \nLatticeApproximation\n([\n1\n,\n2\n,\n3\n,\n4\n,\n5\n],\n \n500000\n)\n\n\n\nPlotLattice\n(\nsol2\n)\n\n\n\n\n\n\nPlotting\n\n\nAs shown in the above, there are three different functions for plotting. We have \ntreeplot\n, \nplotD\n and \nPlotLattice\n functions. \nEach of these functions is special in its own way. Both \ntreeplot\n and \nplotD\n are for plotting scenario trees while \nPlotLattice\n is only for plotting lattice.\nIn this package, we deal also with trees of 2D state space. So you can visualize them after approximation using \nplotD\n function. \nSo the main difference between \ntreeplot\n and \nplotD\n is that  \ntreeplot\n is for trees only in 1D state space while \nplotD\n can be used for trees in 1D and 2D but specifically created for trees in 2D state space.\n\n\n!!! info\n    You need to install the \nPyPlot.jl\n package for this plots.\n\n\nYou can save the plots using the the \nPlots.jl\n function \nsavefig\n:\n\n\nPlots\n.\nsavefig\n(\n\"example1.pdf\"\n)\n\n\n\n\n\n\nThis ends the tutorial for this package.",
            "title": "Tutorial"
        },
        {
            "location": "/tutorial/tutorial1/#introduction",
            "text": "Multistage stochastic optimization involves approximating a stochastic process in by a finite structure.\nWe call these structures a scenario tree and a scanrio lattice.\nScenario lattices plays an important role in approximating Markovian data processes.  We will look at the basic functionality of  ScenTrees.jl  just to highlight on how it works.",
            "title": "Introduction"
        },
        {
            "location": "/tutorial/tutorial1/#goal",
            "text": "The goal is to generate a valuated probability tree or a lattice which represents the stochastic process in the best way possible.  To measure the quality of the approximation, we use a process distance between the stochastic process and the scanario tree or lattice.",
            "title": "Goal"
        },
        {
            "location": "/tutorial/tutorial1/#description-of-a-scenario-tree",
            "text": "A scenario tree is characterized by the following:   Name of the tree  Parents of the nodes in the tree  Children of the parents in the tree   States of the nodes in the tree  Probabilities of transition from one node to another.   The tree is also characterized by its  nodes ,  stages ,  height , leaves  and the  root  of the tree or the nodes.  Each tree has stages starting from  0  where the root node is.",
            "title": "Description of a scenario tree"
        },
        {
            "location": "/tutorial/tutorial1/#description-of-a-scenario-lattice",
            "text": "A scenario lattice differs from a scenario tree in that every node in stage  t  is a child for each node in stage  t-1 . So the nodes in stage  t-1  share the same children.  Due to the above, we only describe a scenario lattice by:   Name of the lattice   States of the nodes of the lattice  Probabilities of transition from one node to another in the lattice",
            "title": "Description of a scenario lattice"
        },
        {
            "location": "/tutorial/tutorial1/#usage",
            "text": "Since we have the basics of the scenario tree and the scenario lattice and since we created  ScenTrees.jl  \nwith an intention of being user-friendly, we will give an example of its usage and explain each part of it.  using   ScenTrees  ex1   =   Tree ([ 1 , 3 , 3 , 3 , 3 ]);  sol1   =   TreeApproximation! ( ex1 ,   GaussianSamplePath ,   100000 , 2 , 2 );  treeplot ( sol1 )   In the above, we are creating a scenario tree with the branching structure  1x3x3x3x3  as  ex1 . \nWe want to approximate the Gaussian random walk with this tree.\nSo, the tree approximation process takes 4 inputs:   A tree  The process to be approximated  Sample size  Which norm (default to Euclidean norm = 2)  The value of  r  for process distance ( default to  r=2 )   Those are basically the inputs that we are giving to the function  TreeApproximation! . \nWhat we obtain as a result of this is a valuated tree which can be visualized by the function  treeplot  or  plotD  if incase you were dealing with a 2-dimensional state space.   Just as easy as that!   It is more even simple for lattice approximation as in this we only take as inputs the branching structure of the lattice and the sample size as follows:  sol2   =   LatticeApproximation ([ 1 , 2 , 3 , 4 , 5 ],   500000 )  PlotLattice ( sol2 )",
            "title": "Usage"
        },
        {
            "location": "/tutorial/tutorial1/#plotting",
            "text": "As shown in the above, there are three different functions for plotting. We have  treeplot ,  plotD  and  PlotLattice  functions. \nEach of these functions is special in its own way. Both  treeplot  and  plotD  are for plotting scenario trees while  PlotLattice  is only for plotting lattice.\nIn this package, we deal also with trees of 2D state space. So you can visualize them after approximation using  plotD  function. \nSo the main difference between  treeplot  and  plotD  is that   treeplot  is for trees only in 1D state space while  plotD  can be used for trees in 1D and 2D but specifically created for trees in 2D state space.  !!! info\n    You need to install the  PyPlot.jl  package for this plots.  You can save the plots using the the  Plots.jl  function  savefig :  Plots . savefig ( \"example1.pdf\" )   This ends the tutorial for this package.",
            "title": "Plotting"
        }
    ]
}