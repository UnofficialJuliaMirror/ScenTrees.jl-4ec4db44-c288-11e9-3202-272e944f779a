var documenterSearchIndex = {"docs":
[{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial5/#Performance-of-ScenTrees.jl-1","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"","category":"section"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"ScenTrees.jl was built with a goal of employing the speed of Julia. This package's design allows us to obtain a fast code with high flexibility and excellent computational efficiency. The design choices are highly motivated by the properties of the Julia language.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The most important concept in Julia is multiple dispatch i.e., the ability to dispatch function calls to different methods depending on the type of all function arguments. Julia arrays are first class objects and linear algebra functions have been integrated into the language standard library hence making it easier for the development of this library.","category":"page"},{"location":"tutorial/tutorial5/#Computational-time-for-trees-of-different-heights-1","page":"Performance of ScenTrees.jl","title":"Computational time for trees of different heights","text":"","category":"section"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"It is important to note that a scenario tree converges in probability for more and more samples that you generated to improve the tree, i.e., if you perform more iterations then you will get a scenario tree that has a better approximation quality than when you perform less iterations.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"One other thing that comes into play for the approximation quality of the scenario tree is the bushiness of the tree. It turns out that having a bushy branching structure produces a scenario tree that has a better approximation quality than a tree with less bushy branching structure. Also, the height of the tree plays a big role on the approximation quality of the scenario tree. Higher trees have a better approximation quality than shorter trees. If we combine these two factors (bushiness and height of the tree), we get a tree which has the best approximation quality of the stochastic process in consideration. The multistage distance converges to 0 as the bushiness of the scenario tree increases. The convergence of the multistage distance holds in probability.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The table below shows the multistage distance of trees of different heights with an increasing branching structure:","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Branches Height = 1 Height = 2 Height = 3 Height = 4\n3 0.24866 0.2177 0.16245 0.11346\n4 0.16805 0.12861 0.08451 0.05236\n5 0.12333 0.08559 0.05073 0.0289\n6 0.09561 0.06042 0.03345 0.01913\n7 0.07752 0.04562 0.02333 0.01188\n8 0.06401 0.03547 0.01711 0.00855","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The above table can be represented in a plot as follows:","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"(Image: Multistage distance for trees of different heights)","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The above plot can be obtained by calling the function bushinessNesDistance() from the package.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Generally, the approximating quality of a scenario tree increases with increasing height of the tree and increasing bushiness of the tree.","category":"page"},{"location":"tutorial/tutorial5/#Comparison-with-MATLAB's-algorithm-1","page":"Performance of ScenTrees.jl","title":"Comparison with MATLAB's algorithm","text":"","category":"section"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Inorder to see how fast Julia is, we compared the performance of different trees with different heights with the same algorithm written in MATLAB programming language. We run the same trees and saved the time it takes to produce results. The following table shows the results (N/B: The time shown is in seconds. (1 minute = 60 seconds)):","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Tree Number of Iterations Time (Julia) Time (MATLAB) How fast Julia is\n1x2x2 10,000 0.1734 6.7532 39\n1x2x2x2 10,000 0.163 9.74 60\n1x2x2x2 100,000 1.77 111.727 63\n1x2x4x8 100,000 2.3093 184.1082 80\n1x2x3x4x5 1,000,000 23.145 1955.66 84\n1x3x3x3x2 1,000,000 20.121 1652.916 82\n1x3x3x3x3 1,000,000 21.443 1752.40 82\n1x10x5x2 1,000,000 23.955 2046.877 85\n1x3x4x4x2x2 1,000,000 27.357 2211.537 81","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"What is clear is that ScenTrees.jl library outperforms MATLAB for all the scenario trees. Also, it is important to see that ScenTrees.jl performs pretty faster for scenario trees which are bushy and has different heights.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The crucial factor that leads to such high speed of computation in Julia is:","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Julia is a multiple dispatch language. Its core design, type-stability through specialization via multiple dispatch is what allows Julia to be very easy for a compiler to make into efficient code, but also allows the code to be very concise and \"look like a scripting language\". This will lead to some very clear performance gain. Type stability is the idea that there is only one possible type that can be outputted from a method. If a function is type-stable, then the compiler can know what type will be at all points in the function and smartly optimize it to the same assembly as C/Fortran.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"Our library totally relies on the above feature. That is why we were able to attain a speed of approximately 80 times than MATLAB.","category":"page"},{"location":"tutorial/tutorial5/#Development-and-Testing-1","page":"Performance of ScenTrees.jl","title":"Development and Testing","text":"","category":"section"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"ScenTrees.jl was developed in Julia 1.0.4 and tested using the standard Julia framework. It was tested for Julia versions 1.0,1.1,1.2 and nightly for the latest release of Julia in Linux and OSX distributions.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"The comparison done for this library in Julia 1.0.4 and MATLAB R2019a was done on Linux(x86_64-pc-Linux-gnu) with CPU(TM) i5-4670 CPU @ 3.40GHz.","category":"page"},{"location":"tutorial/tutorial5/#","page":"Performance of ScenTrees.jl","title":"Performance of ScenTrees.jl","text":"What is more important for testing and development is the processor speed for your machine. Machines with low processors will take longer time to execute the functions than machines with high processors. Hence, depending on the type of processor you have, you may or may not or even pass the computational speed that we achieved for this library.","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial3/#Scenario-Lattices-1","page":"Scenario Lattices","title":"Scenario Lattices","text":"","category":"section"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"If the data process is Markovian, we approximate the process with a scenario lattice instead of a scenario tree. Scenario lattices are natural discretizations of the Markov processes.","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"A scenario lattice is similar to a scenario tree but has an added requirement that all nodes in stage t have the same children. This makes the description of a scenario lattice less than for a scenario tree as a scenario lattice can only be described by its name, states of the nodes in the lattice and the probabilities of transition in the lattice. ","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"In a scenario lattice, the total number of nodes is equal to the total number of states which is equal to the sum of the elements in the branching vector.","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"Consider the scenario lattice below with branching structure 1x2x3x4x5:","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"(Image: Example of a scenario lattice)","category":"page"},{"location":"tutorial/tutorial3/#","page":"Scenario Lattices","title":"Scenario Lattices","text":"In the above scenario lattice, the total number of nodes are 1+2+3+4+5 = 15 nodes and the total number of edges in the lattice are (1x2)+(2x3)+(3x4)+(4x5) = 40 edges. A scenario tree with the same branching structure has 153 nodes and 153 links. This shows that, in a lattice, the number of variables do not grow exponentially as it does in a scenario tree. However, the number of possible paths in a scenario lattice is larger than in a scenario tree.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial4/#Stochastic-Approximation-Process-1","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"","category":"section"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"This package was made for this purpose. Given a stochastic process, we want to approximate the process using either a scenario tree or a scenario lattice.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Every stochastic approximation iteration modifies one path within the tree towards the new sequence. In this way the approximating quality of the tree is improved each time a new sample is observed. The tree is not stable in the beginning but with more and more iterations, the scenario tree converges in probability. The resulting tree can be used for decision making process.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"The stochastic approximation process is outlined as follows:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Decide on the branching structure of the tree/ lattice,\nStart with a tree/lattice (which is more of a qualified guess) with the stated branching structure,\nGenerate one sample from a particular known distribution with the same length and dimension as the states of the nodes of the tree/lattice.\nThe algorithm finds a sequence of nodes in the tree where the distance between the states of those nodes and the generated sample is minimal. The algorithm then updates the states of those nodes with the values in the generated sample. The states of other nodes remains unchanged.\nAt every iteration of the algorithm, the multistage distance is calculated.\nWhen done with the states of the nodes of the tree, the algorithm calculates the conditional probabilities to reach each node in the tree. At the end, the sum of the conditional probabilities to reach each node of the same parent must add up to 1.\nThe algorithm stops when all the number of iterations have been performed.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"tip: Tip\nThe most important function in this approximation process is the function that user wants to approximate. This is the function that generates samples that improves the tree in each iteration. The function must take the number of stages and the dimension as inputs.","category":"page"},{"location":"tutorial/tutorial4/#Tree-Approximation-1","page":"Stochastic Approximation Process","title":"Tree Approximation","text":"","category":"section"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"In this package, we have the function TreeApproximation! which does the stochastic approximation process for scenario trees. This function takes the following inputs:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Tree (which takes the branching structure and dimension and inputs)\nName of the function that generates samples\nNumber of iterations\nValue d for distance (2 is the default for we use the Euclidean distance, 1 would be for the normal distance)\nValue r for the Wasserstein distance (2 is the default for Wasserstein distance)","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Given the following inputs, the function does the stochastic approximation process and returns a valuated scenario tree.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"info: Info\nThe user must provide the above inputs to the function. The user also dictates where the tree starts from in the script that generates samples from a stochastic process that the user wants to approximate.","category":"page"},{"location":"tutorial/tutorial4/#Example-1","page":"Stochastic Approximation Process","title":"Example","text":"","category":"section"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Consider the following. We want to approximate the Gaussian random walk in 5 stages with a tree with a branching structure of 1x3x3x3x3 using the usual Euclidean distance and r=2 for the Wasserstein distance.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"julia> using ScenTrees\njulia> ex2 = Tree([1,3,3,3,3],1)\njulia> sol1 = TreeApproximation!(ex2, GaussianSamplePath, 1000000, 2, 2)\njulia> treeplot(sol1)\njulia> savefig(\"treeapprox1.png\")","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"The function GaussianSamplePath takes the number of stages and the dimension as depicted by the tree that you want to generate. For example, in the above, GaussianSamplePath function will take 5 as the number of stages and 1 as the dimension and then generate  5 samples of a Gaussian distribution.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"The output for the above approximation, shown below, is a scenario tree that is stable and represents the stochastic process in the best possible way.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"(Image: Example of a valuated tree in 1D)","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"We can also appoximate a stochastic process in two dimension. Consider the Gaussian random walk in 2D. Our function GaussianSamplePath can generate samples from the Gaussian random walk in 2 dimension, for example as follows:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"julia> GaussianSamplePath(4,2) # 4 stages, 2 dimension\n3x2 Array{Float64,2}\n1.0         0.0\n-0.4368     -0.4629\n2.3605      -0.2821","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"We can therefore do approximations in 2 dimension as follows:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"julia> ex3 = Tree([1,3,3],2);\njulia> sol2 = TreeApproximation!(ex3,GaussianSamplePath,1000000,2,2);\njulia> plotD(sol2)\njulia> savefig(\"treeapprox2D.png\")","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"(Image: Example of a valuated tree in 2D)","category":"page"},{"location":"tutorial/tutorial4/#Lattice-Approximation-1","page":"Stochastic Approximation Process","title":"Lattice Approximation","text":"","category":"section"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"As mentioned before, some of the process that you may want to approximate are Markovian data processes. These processes can only be approximated by a scenario lattice. All the nodes in the same stage in a lattice have the same children nodes.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"To approximate a Markovian data process, we use the function LatticeApproximation. This function takes the following inputs:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Branching structure,\nName of the function that generates samples and,\nNumber of iterations to be performed, and\nThe dimension of states of the lattice","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Lattice Approximation follows the same stochastic approximation process as for the scenario tree. The only difference is that, in each stage of a lattice, we find the closest lattice entry and use the sample generated to improve it. At the beginning, the lattice is not stable but with more and more iterations, the scenario lattice converges in probability and the resulting lattice can then be used for decision making process.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"All the probabilities in each stage of the lattice must sum up to 1.","category":"page"},{"location":"tutorial/tutorial4/#Example-2","page":"Stochastic Approximation Process","title":"Example","text":"","category":"section"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"Consider the following example. We want to approximate a Gaussian random walk of 12 stages in one dimension with a scenario lattice with the branching structure of 1x3x4x5x6x7x8x9x10x11x12x13 and 1,000,000 iterations.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"julia> sol4 = LatticeApproximation([1,3,4,5,6,7,8,9,10,11,12,13],GaussianSamplePath,1000000);","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"The result of the above approximation is a lattice which we can visualize it.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"info: Info\nTo visualize a scenario lattice, we use the PlotLattice function.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"julia> PlotLattice(sol4)\njulia> savefig(\"LatticeApprox.png\")","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"The above approximation gives the following output:","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"(Image: Example of an approximated lattice)","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"You can see that in the scenario lattice, we have many possibilities than in a scenario tree. Hence, some people prefer a scenario lattice than a scenario tree.","category":"page"},{"location":"tutorial/tutorial4/#","page":"Stochastic Approximation Process","title":"Stochastic Approximation Process","text":"info: Info\nCurrently, lattice approximation can only work for 1 dimension. It is in our working plan to generalize and extend this lattice approximation to any dimension of the states of the scenario lattice.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial1/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"In multistage stochastic optimization, we are interested in approximations of stochastic processes by finite structures. These processes are random and they have uncertain scenarios and a decision maker needs to make decisions at different stages of the process. It is useful to depict the possible sequences of data for this processes in form of a scenario tree in the case of a discrete time stochastic process and a scenario lattice for Markovian data processes.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"A scenario tree/lattice is organized in levels which corresponds to stages 1ldotsT. Each node in a stage has a specified number of predecessors as defined by the branching structure. A node represents a possible state of the stochastic process and the vertices represents the possibility of transition between the two connected nodes. A scenario tree differs from a scenario lattice by the condition that each node in stage t must have one predecessor in stage t-1. For a lattice, that is not the case; all the nodes in stage t-1 share the same children in stage t.","category":"page"},{"location":"tutorial/tutorial1/#Goal-1","page":"Introduction","title":"Goal","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"The goal  of ScenTrees.jl is to generate a valuated probability tree or a lattice which represents the stochastic process in the best way possible. ","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"For example, consider a Gaussian random walk in 5 stages. The starting value of this process is known and fixed, say at 0 and the other values are random. The following plot shows 100 sample paths of this process:","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"(Image: 100 sample paths from Gaussian random walk)","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Using those paths, we generate and improve a scenario tree or a scenario lattice. The number of iterations for the algorithm equals the number of sample paths that we want to generate from the stochastic process and the number of stages in the stochastic process equals the number of stages in the scenario tree or the scenario lattice. There are a lot of different branching structures that the user can choose for a tree that represents this stochastic process. The branching structure shows how many branches each node in the tree has at each stage of the tree. For example, we can use a branching structure of 1x2x2x2x2 for the scenario tree. This means that each node in the tree has two children. Basically, this is a binary tree. Using this branching structure, we obtain the following valuated probability tree that represents the above stochastic process:","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"(Image: Scenario Tree 1x2x2x2x2)","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"The above tree is optimal and therefore can be used by a decision maker for a decision making process depending on the type of problem he/she is handling.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"To measure the quality of the approximation, we use the concept of multistage distance between the stochastic process and the scanario tree or lattice.","category":"page"},{"location":"tutorial/tutorial1/#Multistage-distance-1","page":"Introduction","title":"Multistage distance","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"To measure the distance of stochastic processes, it is not sufficient to only consider the distance between thier laws. It is also important to consider the information accumulated over time i.e., what the filtrations has to tell us over time. The Wasserstein distance do not correctly separate stochastic processes having different filtrations. It ignores filtrations and hence does not distinguish stochastic processes.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Multistage distance was introduced by Georg Ch. Pflug (2009). It turns out that this distance is very important to measure the distence between multistage stochastic processes as it incorporates filtrations introduced by the processes. We use this distance in our algorithm to measure the quality of approximation of the scenario tree. Generally, a scenario tree with a minimal distance to the stochastic process is consider to have a better quality approximation.","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-tree-1","page":"Introduction","title":"Description of a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"A scenario tree is described by the following:","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Name of the tree\nParents of the nodes in the tree\nChildren of the parents in the tree \nStates of the nodes in the tree\nProbabilities of transition from one node to another.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"A scenario tree is a mutable struct of type Tree(). To create a non-optimal scenario tree, we need to fix the branching structure and the dimension of the states of nodes you are wroking on. This typs Tree() has different methods:","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"julia> methods(Tree)\n# 4 methods for generic function \"(::Type)\":\n[1] Tree(name::String, parent::Array{Int64,1}, children::Array{Array{Int64,1},1}, state::Array{Float64,2}, probability::Array{Float64,2}) \n[2] Tree(identifier::Int64) \n[3] Tree(spec::Array{Int64,1}) \n[4] Tree(spec::Array{Int64,1}, dimension) ","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"All the methods correspond to the way you can create a scenario tree. For the first method, the length of states must be equal to the length of the probabilities. In the 2nd method, you can call any of our predefined trees by just calling on the identifier (these identifiers are 0,301,302,303,304,305,306,307,401,402,4022,404,405). And finaly the most important methods are the 3rd and 4th method. If you know the branching structure of your scenario tree, then you can create an non-optimal starting tree using it. If you don't state the dimension you ae working on, then it is defaulted into 1. For example, Tree([1,2,2]) creates a binary tree with states of dimension one.","category":"page"},{"location":"tutorial/tutorial1/#Description-of-a-scenario-lattice-1","page":"Introduction","title":"Description of a scenario lattice","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"A scenario lattice differs from a scenario tree in that every node in stage t is a child for each node in stage t-1. So the nodes in stage t-1 share the same children.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Due to the above, we only describe a scenario lattice by:","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Name of the lattice\nStates of the nodes of the lattice\nProbabilities of transition from one node to another in the lattice","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"A scenario lattice has only one method.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"julia> methods(Lattice)\n 1 method for generic function \"(::Type)\":\n[1] Lattice(name::String, state::Array{Array{Float64,2},1}, probability::Array{Array{Float64,2},1})","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"This method is not very important becasue we only need it to produce the results of the lattice approximation process. We will see later that for lattice approximation, we need the branching structure and so the structure of the lattice is not very important as in the case of a scenario tree.","category":"page"},{"location":"tutorial/tutorial1/#Usage-1","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"Since we have the basics of the scenario tree and the scenario lattice and since we created ScenTrees.jl with an intention of being user-friendly, we will give an example of its usage and explain each part of it.  In the module of ScenTrees.jl, we have all the exported functions that are visible to the user i.e, that are public, and the user can call these functions depending on what he/she wants to achieve with this library","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"module ScenTrees\n  include(\"TreeStructure.jl\")\n  include(\"TreeApprox.jl\")\n  include(\"StochPaths.jl\")\n  include(\"LatticeApprox.jl\")\n  export TreeApproximation!, LatticeApproximation, Tree, nodes, stage, height, leaves,\n        root,partTree, buildProb!, treeplot, plotD, PlotLattice,\n        GaussianSamplePath,RunningMaximum\nend","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"The most important functions in this module are TreeApproximation!() and LatticeApproximation() since these are the tow functions which are used to approximate scenario trees and scenario lattices respectively. The other important function is the Tree() function which gives the basic structure of the scenario tree.","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"All of the above functions have been documented in their respective scripts and the user can find out what each function does by putting a ? before the function. For example, ?leaves will give an explanation of what the function leaves does. ","category":"page"},{"location":"tutorial/tutorial1/#","page":"Introduction","title":"Introduction","text":"In the upcoming tutorials, we will have a look in detail on the functionalities of the main functions of this library.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"CurrentModule = ScenTrees","category":"page"},{"location":"#ScenTrees.jl-1","page":"Home","title":"ScenTrees.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"info: Info\n","category":"page"},{"location":"#","page":"Home","title":"Home","text":"`ScenTrees.jl` is still under development.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"ScenTrees.jl is a package for generating and improving scenario trees and scenario lattices for multistage stochastic optimization problems using stochastic approximation. In this library, we use a fixed number of trajectories of a stochastic process to generate and improve a scenario tree or a scenario lattice. The quality of approximation between the stochastic process and the scenario tree/ the scenario lattice is measure using a multistage distance. The resulting scenario tree/lattice is optimal and represents the stochastic process in the best possible way and so can be used for decision making process.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In these tutorials, we assume that the reader is quite familiar with the theory and explanation in the paper Georg Ch. Pflug and Alois Pichler(2015).","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The library ScenTrees.jl is on the registration process and can be installed in Julia as follows:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"]      # For the Pkg mode\nadd https://github.com/kirui93/ScenTrees.jl.git","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Once you have ScenTrees.jl installed, we recommend that you have a look on the tutorials from the beginning to the end to understand on how you can use the package to do scenario tree/lattice generation by the stochastic approximation process.","category":"page"},{"location":"#Citing-ScenTrees.jl-1","page":"Home","title":"Citing ScenTrees.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"info: Info\n","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To be added.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"CurrentModule = ScenTrees","category":"page"},{"location":"tutorial/tutorial2/#Scenario-Trees-1","page":"Scenario Trees","title":"Scenario Trees","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"Consider a general stochastic process X over a discrete time space T, i.e., X = (X_0X_T) where X_0 is a deterministic starting value and the rest are random values or random vectors whose probability distribution is known. A scenario tree is a discrete time and discrete state process approximating the process X. We represent the scenario tree by tildeX = (tildeX_0tildeX_T). A scenario is a path from the root node to any of the leaves in the tree. The number of stages in a scenario must be equal to the number of stages in a scenario tree which is equal to the length of the sample from the stochastic process X.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"A basic scenario tree can be created using the Tree function in the package. This function takes the branching structure of the tree and the dimension that you are working on. For example, consider a tree with a branching structure of 1x2x2. This is a tree with a root in stage 0, and 2 nodes in stage 1 and each of the 2 nodes in stage one has 2 nodes in stage 2.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example1 = Tree([1,2,2],1)\njulia> treeplot(example1)","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree basically is not optimal. This is an example of a beginning tree in stochastic approximation process. we start with a tree like this and then we use samples from a known distribution to improve the tree for a certain number of iterations.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Non optimal tree in 1D)","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree is in 1-state dimension. To generate a tree in 2-state dimension, we use the following:","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> example2 = Tree([1,2,2],2)\njulia> plotD(example2)","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Non optimal tree in 2D)","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"And in general, we can generate a tree in any d state dimension.","category":"page"},{"location":"tutorial/tutorial2/#Functions-describing-a-scenario-tree-1","page":"Scenario Trees","title":"Functions describing a scenario tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The above tree can described by the following functions: nodes, stages, height, leaves and the root of the tree.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"Each tree has stages starting from 0 where the root node is.","category":"page"},{"location":"tutorial/tutorial2/#Nodes-of-the-tree-1","page":"Scenario Trees","title":"Nodes of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"This are the vertices that are in the scenario tree. Each node in the tree has a parent node except the root node where the tree starts from. As stated before, each scenario tree is characterized by its name, parents of the nodes , children of each parent nodes e.t.c. So therefore, we have nodes which has parents and those nodes are the children of the parent nodes.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"For example,","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> nodes(example1)\n1:7","category":"page"},{"location":"tutorial/tutorial2/#Stages-of-the-tree-1","page":"Scenario Trees","title":"Stages of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"Each node in a tree is in a specific stage and nodes in the same stage have the same number of children. The stages in a tree starts from 0 where the root node is and ends at stage T`where the leaf nodes are.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> stage(example1)\n0\n1\n1\n2\n2\n2\n2","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The above example shows that we have 1 node in stage 0, 2 nodes in stage 1 and 4 nodes in stage 2.","category":"page"},{"location":"tutorial/tutorial2/#Root-of-the-tree-1","page":"Scenario Trees","title":"Root of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The root of the tree is the node in which the tree starts from. The root of the tree has no parent; more or less, is the parent of all nodes.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> root(example1)\n1-element Array{Int64,1}\n1","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"The function root can also give us a sequence of nodes to reach a particular node of the tree. It turns out that this function will be very important in stochastic approximation as it will give us a path that we can improve with samples from a stochastic process.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"If we want a sequence of nodes to reach, for example, node 6 in the above tree, we just call out the root`function as follows:","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> root(example1,6)\n3-element Array{Int64,1}\n1\n3\n6","category":"page"},{"location":"tutorial/tutorial2/#Leaves-of-the-tree-1","page":"Scenario Trees","title":"Leaves of the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"In each tree, we have the leaves. Leaves are all those in the tree which doesn't have children nodes. They are the terminal nodes in the tree. Our function leaves returns the leaf nodes in the tree, their indexes and the conditional probabilities to reach each of the leaves from the root node. Consider the following:","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> leaves(example1)\n([4,5,6,7],1:4,[0.2508,0.1709,0.2566,0.2508])","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"From the above, it is clear that the sum of the conditional probabilities to reach all the leaves in the tree is 1.","category":"page"},{"location":"tutorial/tutorial2/#Plotting-the-tree-1","page":"Scenario Trees","title":"Plotting the tree","text":"","category":"section"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"One of the most important things in programming is visualization. In this package, we can plot a scenario tree in 1D with the treeplot function and with the plotD function for a scenario tree in D dimension.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"info: Info\n","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"You need to install the [PyPlot.jl](https://github.com/JuliaPy/PyPlot.jl) package for this plots.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"For example, we can plot a default tree already in the package and then the figure can be saved with the function savefig. These trees can be accessed through an identifier which is just a number. These identifiers are 0,301,302,303,304,305,306,307,401,402,4022,404,405. Therefore, for these examples, you can just access them through their identifie. For example, Tree(402) returns tree with the identifier 402.","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> treeplot(Tree(402))\njulia> savefig(\"Tree402.png\")","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Example of a tree in 1D)","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"We can plot a tree in 2 dimension as follows:","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"julia> treeplot(Tree(4022))\njulia> savefig(\"Tree4022.png\")","category":"page"},{"location":"tutorial/tutorial2/#","page":"Scenario Trees","title":"Scenario Trees","text":"(Image: Example of a tree in 2D)","category":"page"}]
}
