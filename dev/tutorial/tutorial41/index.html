<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kernel Density Estimation · ScenTrees.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="ScenTrees.jl logo"/></a><h1>ScenTrees.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorial1/">Introduction</a></li><li><a class="toctext" href="../tutorial2/">Scenario Trees</a></li><li><a class="toctext" href="../tutorial3/">Scenario Lattices</a></li><li><a class="toctext" href="../tutorial31/">Stochastic processes</a></li><li><a class="toctext" href="../tutorial4/">Stochastic Approximation Process</a></li><li class="current"><a class="toctext" href>Kernel Density Estimation</a><ul class="internal"><li><a class="toctext" href="#Implementation-of-the-above-process-1">Implementation of the above process</a></li></ul></li><li><a class="toctext" href="../tutorial5/">Performance of <code>ScenTrees.jl</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Kernel Density Estimation</a></li></ul><a class="edit-page" href="https://github.com/kirui93/ScenTrees.jl/blob/master/docs/src/tutorial/tutorial41.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Kernel Density Estimation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Kernel-Density-Estimation-1" href="#Kernel-Density-Estimation-1">Kernel Density Estimation</a></h1><p>This is a non-parametric technique for generating trajectories used to generate and improve scenario trees and scenario lattices in the stochastic approximation algorithm. It involves two steps:</p><pre><code class="language-none">1. Density estimation and,
2. Stochastic approximation process.</code></pre><p>In thit tutorial we will concentrate on the first step as stochastic approximation process is already discussed in the previous tutorial. </p><p>For the density estimation step, we have an <code>(N x T)</code> data from some observed trajectories of a scenario process and we want to use the conditional density estimation to generate new but different sample based on the above trajectories. This process involves two steps:</p><pre><code class="language-none">(a) Estimation of the distribution of conditional denstities and,
(b) Composition method</code></pre><p>We estimate the distribution of transition densities given the history of the process. This distribution can be estimated by the non-parametric kernel density estimation. The density at stage <span>$t+1$</span> conditional on the history <span>$\mathbf{x_{t}} = (x_0,x_{i_{1}},x_{i_{2}},\ldots,x_{i_{t}})$</span> is estimated by </p><div>\[\hat{f}_{t+1}(x_{t+1}|\mathbf{x_{t}}) = \sum_{j=1}^{N} \omega_j(\mathbf{x_{t}}) \cdot k_{h_N}(x_{t+1} - \xi_{j,t+1})\]</div><p>where <span>$k(.)$</span> is a kernel function, <span>$h_N$</span> is the bandwidth and <span>$k_{h_N}$</span> is the weighted kernel function.</p><p>The weights are given by</p><div>\[\omega_j(\mathbf{x_{t}}) = \frac{k\big(\frac{x_{i_1} - \xi_{j,1}}{h_N}\big)\cdot \ldots \cdot k\big(\frac{x_{i_t} - \xi_{j,t}}{h_N}\big)}{\sum_{\ell=1}^{N}k\big(\frac{x_{i_1} - \xi_{l,1}}{h_N}\big)\cdot \ldots \cdot k\big(\frac{x_{i_t} - \xi_{l,t}}{h_N}\big)}.\]</div><p>Notice from above that the weights depend on the history <span>$\mathbf{x_{t}}$</span> upto stage <span>$t$</span> only. Also, the weights sum up to 1 for every <span>$\mathbf{x_{t}}$</span>, i.e., <span>$\sum_{j=1}^{N} \omega_j(\mathbf{x_{t}}) = 1$</span>.</p><p>We use the composition method to generate samples from the conditional distribution <span>$\hat{f}_{t+1}(.|\mathbf{x_{t}})$</span> as follows. Pick a random number <span>$U \in (0,1)$</span> where <span>$U$</span> is uniformly distributed then find a summation index <span>$j^{\star} \in {1,2,\ldots,N}$</span> such that </p><div>\[\sum_{j=1}^{j^{\star}-1} \omega_j(\mathbf{x_{t}}) &lt; U \leq \sum_{j=1}^{j^{\star}} \omega_j(\mathbf{x_{t}}).\]</div><p>The cumulative sum of weights leads to a high probability of picking a data path near the observation.</p><p>The value of the data <span>$\xi_t$</span> is obtained by setting the value at stage <span>$t$</span> to </p><div>\[\xi_t = X_{j^{\star,t}} + \text{rand}_{k_{h_N}}\]</div><p>where <span>$\text{rand}_{k_{h_N}}$</span> is a random value sampled from the kernel estimator using the composition method.</p><p>The generated data point is according to the distribution of the density at the current stage and dependent on the history of all the data points. It has been shown that the choice of the kernel does not have an important effect on density estimation. Hence, we employ the following logistic kernel in this paper <span>$k(x) = \frac{1}{(e^x + e^{-x})^2}.$</span></p><p>One of the most important factor to consider in density estimation is the bandwidth. We use the Silverman&#39;s rule of thumb to obtain the bandwidths for each of the data columns as follows  <span>$h_N = \sigma(X_t)\cdot N^{\frac{-1}{N+4}}$</span> where <span>$N$</span> is the number of available trajectories and <span>$\sigma(X_t)$</span> is the standard deviation of data in stage <span>$t$</span>.</p><p>Using the above procedure, every new sample path starts with <span>$\mathbf{\tilde{\xi_1}} := (x_1)$</span>. Using the above procedure, we find a new sample <span>$\tilde{\xi_2}$</span> from <span>$\hat{f}_1(.|\mathbf{\tilde{\xi_1}})$</span> at the first stage. Next, we set <span>$\mathbf{\tilde{\xi_2}} = (\tilde{\xi_1},\tilde{\xi_2})$</span> and generate a new data point <span>$\tilde{\xi_2}$</span> from <span>$\hat{f}_2(.|\mathbf{\tilde{\xi_1}})$</span>  at the second stage. The process continues in that manner until the final stage <span>$T$</span> where we get the final new sample path <span>$\mathbf{\tilde{\xi_T}} = (\tilde{\xi_0},\tilde{\xi_1},\ldots,\tilde{\xi_T})$</span> which is generated form the initial data <span>$\xi = (\xi_1,\xi_2,\ldots,\xi_T)$</span>. The new sample path <span>$\mathbf{\tilde{\xi_T}}$</span> is what we will feed in the stochastic approximation algorithm to generate a scenario tree or a scenario lattice.</p><h2><a class="nav-anchor" id="Implementation-of-the-above-process-1" href="#Implementation-of-the-above-process-1">Implementation of the above process</a></h2><p>The above process is implemented in our library in <code>KernelDensityEstimation.jl</code>.In this script, we use the concept of function closures which wehope that the user is aware of. The user of this function is required to provide a data in 2 dimension to this function. In the procedure below, we use the function <code>Matrix</code> to convert the loaded dataframe into a matrix which is an array in two dimension.</p><p>The function <code>KernelScenarios(data::Union{Array{Int64,2},Array{Float64,2}})</code> takes a <span>$(N \times T)$</span> dimensional data. The <span>$N$</span> rows of the data are the number of trajectories in the initial data and the <span>$T$</span> columns is the number of stages in in each trajectory of the data. Since <code>TreeApproximation!</code> and <code>LatticeApproximation</code> function needs a process function for generating samples that doesn&#39;t take any inputs, we employ the concept of function closures inside the above function. The function <code>KernelScenarios(data)</code> is a getfield type of a function closure and so is sufficient to be a function required for stochastic approximation process.</p><p>To confirm the above statement, consider a <code>1000x5</code> dimsneional data from random walk. What is important to be said is that we use the package <code>CSV</code>^[https://github.com/JuliaData/CSV.jl] to read the data into julia and since we need the data in matrix form, we use the function <code>Matrix</code> from the package <code>DataFrames</code>^[https://github.com/JuliaData/DataFrames.jl] to convert the dataframe into an array in two dimension which is then the input of our function.</p><pre><code class="language-julia">julia&gt; using ScenTrees, CSV
julia&gt; data = CSV.read(&quot;.../RandomDataWalk.csv&quot;)
julia&gt; Rdw = Matrix(data)
julia&gt; Kdt = KernelScenarios(Rwd)
(::getfield(ScenTrees, Symbol(&quot;#closure#52&quot;)){Array{Float64,2},Int64,Int64,Array{Float64,1},Array{Float64,1},Array{Float64,1}}) (generic function with 1 method)
julia&gt; ExampleTraj = KernelScenarios(Rwd)()
5-element Array{Float64,1}:
  2.9313349319144413
 -2.096361853760116 
  3.767121571013698 
  2.147647884035623 
  0.9424061566897852</code></pre><p>As in <code>ExampleTraj</code>, this function returns is a new sample according to the distribution of the density at the current stage and dependent on the history of all the data points. </p><p>We use the above data to approximate a scenario lattice in 5 stages with a braching structure of <span>$(1\times 3\times 4\times 5\times6)$</span>  and <span>$100,000$</span> number of iterations as follows:</p><pre><code class="language-julia">julia&gt; KernExample = LatticeApproximation([1,3,4,5,6],KernelScenarios(Rwd),100000);
julia&gt; PlotLattice(KernExample)</code></pre><p>The above plot function gives the following plot result:</p><p><img src="../../assets/KernLattice.png" alt="Scenario Lattice From Kernel Trajectories"/></p><footer><hr/><a class="previous" href="../tutorial4/"><span class="direction">Previous</span><span class="title">Stochastic Approximation Process</span></a><a class="next" href="../tutorial5/"><span class="direction">Next</span><span class="title">Performance of <code>ScenTrees.jl</code></span></a></footer></article></body></html>
