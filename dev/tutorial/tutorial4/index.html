<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Approximation Process · ScenTrees.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../"><img class="logo" src="../../assets/logo.png" alt="ScenTrees.jl logo"/></a><h1>ScenTrees.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorial1/">Introduction</a></li><li><a class="toctext" href="../tutorial2/">Scenario Trees</a></li><li><a class="toctext" href="../tutorial3/">Scenario Lattices</a></li><li><a class="toctext" href="../tutorial31/">Stochastic processes</a></li><li class="current"><a class="toctext" href>Stochastic Approximation Process</a><ul class="internal"><li><a class="toctext" href="#Tree-Approximation-1">Tree Approximation</a></li><li><a class="toctext" href="#Lattice-Approximation-1">Lattice Approximation</a></li></ul></li><li><a class="toctext" href="../tutorial5/">Performance of <code>ScenTrees.jl</code></a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>Stochastic Approximation Process</a></li></ul><a class="edit-page" href="https://github.com/kirui93/ScenTrees.jl/blob/master/docs/src/tutorial/tutorial4.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Stochastic Approximation Process</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Stochastic-Approximation-Process-1" href="#Stochastic-Approximation-Process-1">Stochastic Approximation Process</a></h1><p>This package was made for this purpose. Given a stochastic process, we want to approximate the process using either a scenario tree or a scenario lattice.</p><p>Every stochastic approximation iteration modifies one path within the tree towards the new sequence. In this way the approximating quality of the tree is improved each time a new sample is observed. The tree is not stable in the beginning but with more and more iterations, the scenario tree converges in probability. The resulting tree can be used for decision making process.</p><p>The stochastic approximation process is outlined as follows:</p><ol><li><p>Decide on the branching structure of the tree/ lattice,</p></li><li><p>Start with a tree/lattice (which is more of a qualified guess) with the stated branching structure,</p></li><li><p>Generate one sample from a particular known distribution with the same length and dimension as the states of the nodes of the tree/lattice.</p></li><li><p>The algorithm finds a sequence of nodes in the tree where the distance between the states of those nodes and the generated sample is minimal. The algorithm then updates the states of those nodes with the values in the generated sample. The states of other nodes remains unchanged.</p></li><li><p>At every iteration of the algorithm, the multistage distance is calculated.</p></li><li><p>When done with the states of the nodes of the tree, the algorithm calculates the conditional probabilities to reach each node in the tree. At the end, the sum of the conditional probabilities to reach each node of the same parent must add up to 1.</p></li><li><p>The algorithm stops when all the number of iterations have been performed.</p></li></ol><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>The most important function in this approximation process is the function that user wants to approximate. This is the function that generates samples that improves the tree in each iteration. <em>The function must be designed in a way that it doesn&#39;t take any inputs. It must be a hardcoded function in that and the length of an array that it produces must match the number of stages of the tree and the dimension of the states of the tree.</em></p></div></div><h2><a class="nav-anchor" id="Tree-Approximation-1" href="#Tree-Approximation-1">Tree Approximation</a></h2><p>In this package, we have the function <code>TreeApproximation!(Tree(BranchingStructure,dimension),Function,NumberOfIterations,2,2)</code> which does the stochastic approximation process for scenario trees. This function takes the following inputs:</p><ul><li><p>Tree (which takes the branching structure and dimension and inputs)</p></li><li><p>Name of the function that generates samples</p></li><li><p>Number of iterations</p></li><li><p>Choice <code>d</code> of the norm (Example: <code>max=0,sum=1,Euclidean=2</code>(default))</p></li><li><p>Choice <code>r</code> for the Wasserstein distance (<code>r=2</code>(default))</p></li></ul><p>Given the above inputs, the function does the stochastic approximation process and returns a valuated scenario tree.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>The user must provide the above inputs to the function. The user also dictates where the tree starts from in the script that generates samples from a stochastic process that the user wants to approximate.</p></div></div><h3><a class="nav-anchor" id="Example-1" href="#Example-1">Example</a></h3><p>Consider the following. We want to approximate the Gaussian random walk in 4 stages with a tree with a branching structure of <code>1x3x3x3</code> in 1 dimension using the usual Euclidean distance ,<code>pNorm=2</code> and <code>rWasserstein=2</code> for the Wasserstein distance.</p><pre><code class="language-julia">julia&gt; using ScenTrees
julia&gt; ex2 = Tree([1,3,3,3],1)
julia&gt; sol1 = TreeApproximation!(ex2, GaussianSamplePath1D,1000000,2,2)
julia&gt; treeplot(sol1)
julia&gt; savefig(&quot;treeapprox1.png&quot;)</code></pre><p>The function <code>GaussianSamplePath1D()</code> takes no inputs and generates one trajectory of the Gaussian random walk in 4 stages. For each iteration of the process, this process function generates a trajectory that will help improve the states of the nodes in the scenario tree.</p><pre><code class="language-julia">julia&gt; GaussianSamplePath1D()   # 4 stages, 1 dimension
4x1 Array{Float64,2}:
0.0
1.49765
-0.17537
-1.2982</code></pre><p>The output for the above approximation, shown below, is a scenario tree that is stable and represents the stochastic process in the best possible way.</p><p><img src="../../assets/treeapprox1.png" alt="Example of a valuated tree in 1D"/></p><p>We can also appoximate a stochastic process in two dimension. Consider the Gaussian random walk in 2D. Our function <code>GaussianSamplePath2D</code> can generate samples from the Gaussian random walk in 2 dimension, for example as follows:</p><pre><code class="language-julia">julia&gt; GaussianSamplePath2D() # 4 stages, 2 dimension
4x2 Array{Float64,2}
1.0000        0.0000
0.76636      -0.44216
3.65296      -0.14275
5.1779       -0.42350</code></pre><p>We can therefore do approximations in 2 dimension as follows:</p><pre><code class="language-julia">julia&gt; ex3 = Tree([1,3,3,3],2);
julia&gt; sol2 = TreeApproximation!(ex3,GaussianSamplePath2D,1000000,2,2);
julia&gt; plotD(sol2)
julia&gt; savefig(&quot;treeapprox2D.png&quot;)</code></pre><p><img src="../../assets/treeapprox2D.png" alt="Example of a valuated tree in 2D"/></p><h2><a class="nav-anchor" id="Lattice-Approximation-1" href="#Lattice-Approximation-1">Lattice Approximation</a></h2><p>As mentioned before, some of the process that you may want to approximate are Markovian data processes. These processes can only be approximated by a scenario lattice. All the nodes in the same stage in a lattice have the same children nodes.</p><p>To approximate a Markovian data process, we use the function <code>LatticeApproximation(BranchingStructure,Function,NoOfIterations)</code>. The following are the description of the inputs of the funtion:</p><ul><li>Branching structure of the scenario lattice,</li><li>Function that generates samples and,</li><li>Number of iterations to be performed, </li></ul><p>Lattice Approximation follows the same stochastic approximation process as for the scenario tree. The only difference is that, in each stage of a lattice, we find the closest lattice entry and use the sample generated to improve it. At the beginning, the lattice is not stable but with more and more iterations, the scenario lattice converges in probability and the resulting lattice can then be used for decision making process.</p><p>All the probabilities in each stage of the lattice must sum up to 1.</p><h3><a class="nav-anchor" id="Example-2" href="#Example-2">Example</a></h3><p>Consider the following example. We want to approximate a Gaussian random walk of 4 stages in one dimension with a scenario lattice with the branching structure of <code>1x3x4x5</code> and 1,000,000 iterations.</p><pre><code class="language-julia">julia&gt; sol4 = LatticeApproximation([1,3,4,5],GaussianSamplePath1D,1000000);</code></pre><p>The result of the above approximation is a scenario lattice which represents the stochastic process in the best way. This scenario lattice can be used for decision making process under uncertainty </p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>To visualize a scenario lattice, we use the <code>PlotLattice</code> function.</p></div></div><pre><code class="language-julia">julia&gt; PlotLattice(sol4)
julia&gt; savefig(&quot;LatticeApprox.png&quot;)</code></pre><p>The above approximation gives the following output:</p><p><img src="../../assets/LatticeApprox.png" alt="Example of an approximated lattice"/></p><p>You can see that in the scenario lattice, we have many possibilities than in a scenario tree. Hence, some people prefer a scenario lattice than a scenario tree.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>Currently, lattice approximation can only work for 1 dimension. It is in our working plan to generalize and extend this lattice approximation to any dimension of the states of the scenario lattice.</p></div></div><footer><hr/><a class="previous" href="../tutorial31/"><span class="direction">Previous</span><span class="title">Stochastic processes</span></a><a class="next" href="../tutorial5/"><span class="direction">Next</span><span class="title">Performance of <code>ScenTrees.jl</code></span></a></footer></article></body></html>
